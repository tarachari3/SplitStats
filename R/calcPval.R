#' A Function to return raw p-values for feature contribution to a split
#'
#' @param featureMat Unnamed matrix of observationsxfeature
#' @param labels Vector of observation labels (e.g. member names)
#' @param queryLabs Subset of labels vector on one side of split
#' @return P-values for contribution of feature to split
#' @export

# ---------------------- Rank votes by p-value for given split ------------------ (FOR PACKAGE)
calcSplitVotPval <- function(featureMat,labels, queryLabs) {

  bin_names <- as.integer(labels %in% queryLabs)

  feats <- unique(as.vector(featureMat))

  rollcallNums <- 1:dim(featureMat)[2]
  pvals <- numeric(dim(featureMat)[2])
  #For each vote (Col of votesDem)
  for (i in rollcallNums){

    votes <- featureMat[,i]


    #Construct contingency table for each vote relative to split of interest
    zero_names <-  bin_names == 0
    one_names <-  bin_names == 1

    zeroFilt_votes <- votes[zero_names]
    oneFilt_votes <- votes[one_names]

    row1 <- rep(0,length(feats))
    row2 <- rep(0,length(feats))

    for (p in c(1:length(feats))){

      row1[p] <- sum(zeroFilt_votes == feats[p])
      row2[p] <- sum(oneFilt_votes == feats[p])
    }


    pvals[i] <- fisher.test(rbind(row1,row2), alternative="two.sided")$p.value

  }
  return(pvals)
}


#' Get splits from NNet generated split network
#'
#'
#'
#' @return List of observations in cycle ordering and split objects
#'
#' @param labels Vector of observation labels (e.g. member names)
#' @param matrix (Square) Distance matrix with no labels (unnamed)
#' @export
#' @importFrom reticulate import
#' @importFrom basilisk basiliskStart basiliskRun basiliskStop
getSplits <- function(labels, matrix) {

  cl <- basiliskStart(env4)
  cycSplit <- basiliskRun(cl, function() {
    path <- system.file("splitspy", package = 'SplitStats')
    X <- reticulate::import_from_path("splitspy", path = path)
    X$calcSplits(labels, matrix)
  })
  basiliskStop(cl)

  return(cycSplit)
}


#' Get split distances between two groups of observations
#'
#'
#'
#' @return Vector of distances from each query input to set of all observations in refLabs
#'
#' @param labels: Vector of observation labels
#' @param queryLabs: Vector of observation labels on one side of a split
#' @param refLabs: Vector of reference observations labels
#' @param splits: Collection of split objects generated by getSplits
#' @export
#' @importFrom reticulate import
#' @importFrom basilisk basiliskStart basiliskRun basiliskStop
getSplitDist <- function(labels, queryLabs, refLabs, splits) {

  cl <- basiliskStart(env4)
  cycSplit <- basiliskRun(cl, function() {
    X <- reticulate::import("splitspy")
    X$splitDists(labels, queryLabs, refLabs, splits)
  })
  basiliskStop(cl)

  return(dists)
}

#' Visualize split network as splits graph
#'
#'
#'
#' @return Image and NEXUS file output
#' @author Tara Chari
#'
#' @param labels : Vector of labels for members (observations) in dataset
#' @param cycle : Vector of circular ordering of labels from getSplits
#' @param splits : Split objects between members from getSplits
#' @param matrix : Square distance matrix (used as input to getSplits)
#' @param outfilePhylo : Filename for phylogenetic outline image of splits network
#' @param outfileNexus : Filename for NEXUS output of splits network (SplitsTree4/5 compatible)
#' @export
#' @importFrom reticulate import
#' @importFrom basilisk basiliskStart basiliskRun basiliskStop
getSplitVis <- function(labels,cycle,splits,matrix,outfilePhylo,outfileNexus) {

  cl <- basiliskStart(env4)
  cycSplit <- basiliskRun(cl, function() {
    X <- reticulate::import("splitspy")
    X$makeVis(labels,cycle,splits,matrix,outfilePhylo,outfileNexus)
  })
  basiliskStop(cl)

}
