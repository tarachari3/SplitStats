#' Get raw p-values for feature contribution to a split of interest
#' @return P-values for contribution of feature to split
#'
#' @param featureMat Unnamed matrix of observationsxfeatures (e.g. membersxvotes)
#' @param labels Vector of observation labels (e.g. member names)
#' @param queryLabs Subset of labels vector on one side of split
#'
#' @examples
#' featMat <- cbind(c(0,1,1,1,1),c(0,0,0,1,1),c(0,1,1,1,1),c(0,1,0,1,1),c(0,0,0,0,0),c(0,1,1,0,0))
#' labs <- c('Mouse','Fly','Rat','Zebrafish','Human')
#' queries <- c('Mouse','Rat')
#' pvals <- calcVotPval(featMat,labs,queries)
#' @export
#' @importFrom stats fisher.test

# ---------------------- Rank votes by p-value for given split ------------------ (FOR PACKAGE)
calcVotPval <- function(featureMat,labels, queryLabs) {

  bin_names <- as.integer(labels %in% queryLabs)

  feats <- unique(as.vector(featureMat))

  rollcallNums <- 1:dim(featureMat)[2]
  pvals <- numeric(dim(featureMat)[2])
  #For each vote (Col of votesDem)
  for (i in rollcallNums){

    votes <- featureMat[,i]


    #Construct contingency table for each vote relative to split of interest
    zero_names <-  bin_names == 0
    one_names <-  bin_names == 1

    zeroFilt_votes <- votes[zero_names]
    oneFilt_votes <- votes[one_names]

    row1 <- rep(0,length(feats))
    row2 <- rep(0,length(feats))

    for (p in c(1:length(feats))){

      row1[p] <- sum(zeroFilt_votes == feats[p])
      row2[p] <- sum(oneFilt_votes == feats[p])
    }


    pvals[i] <- fisher.test(rbind(row1,row2), alternative="two.sided")$p.value

  }
  return(pvals)
}


#' Get splits and cycle ordering from NNet generated split network
#'
#'
#'
#' @return List of observations in cycle ordering and split objects
#'
#' @param labels Vector of observation labels (e.g. member names)
#' @param matrix (Square) Distance matrix with no labels (unnamed)
#' @examples
#' dists <- dist(cbind(c(0,1,1,1,1),c(0,0,0,1,1),c(0,1,1,1,1),c(0,1,0,1,1),c(0,0,0,0,0),c(0,1,1,0,0)), method = "manhattan",diag=TRUE,upper=TRUE)
#' labs <- c('Mouse','Fly','Rat','Zebrafish','Human')
#' out <- getSplits(labs, dists)
#' @export
#' @importFrom reticulate import
#' @importFrom basilisk basiliskStart basiliskRun basiliskStop
getSplits <- function(labels, matrix) {

  cl <- basiliskStart(env4)
  cycSplit <- basiliskRun(cl, function() {
    path <- system.file("splitspy", package = 'SplitStats')
    X <- reticulate::import_from_path("splitspy", path = path)
    X$calcSplits(labels, matrix)
  })
  basiliskStop(cl)

  return(cycSplit)
}


#' Get split distances between two groups of observations (members)
#'
#'
#'
#' @return Vector of distances from each query input to set of all observations in refLabs
#'
#' @param labels : Vector of observation labels
#' @param queryLabs : Vector of observation labels on one side of a split
#' @param refLabs : Vector of reference observations labels
#' @param splits : Collection of split objects generated by getSplits
#' @examples
#' dists <- dist(cbind(c(0,1,1,1,1),c(0,0,0,1,1),c(0,1,1,1,1),c(0,1,0,1,1),c(0,0,0,0,0),c(0,1,1,0,0)), method = "manhattan",diag=TRUE,upper=TRUE)
#' labs <- c('Mouse','Fly','Rat','Zebrafish','Human')
#' out <- getSplits(labs, dists)
#' splits <- out[2][[1]]
#' sdists <- getSplitDist(labs, labs[1:3], labs[4:6], splits)
#' @export
#' @importFrom reticulate import
#' @importFrom basilisk basiliskStart basiliskRun basiliskStop
getSplitDist <- function(labels, queryLabs, refLabs, splits) {

  cl <- basiliskStart(env4)
  dists <- basiliskRun(cl, function() {
    path <- system.file("splitspy", package = 'SplitStats')
    X <- reticulate::import_from_path("splitspy", path = path)
    X$splitDists(labels, queryLabs, refLabs, splits)
  })
  basiliskStop(cl)

  return(dists)
}

#' Visualize split network as splits graph
#'
#'
#'
#' @return Image and NEXUS file output
#' @author Tara Chari
#'
#' @param labels : Vector of labels for members (observations) in dataset
#' @param cycle : Vector of circular ordering of labels from getSplits
#' @param splits : Split objects between members from getSplits
#' @param matrix : Square distance matrix (used as input to getSplits)
#' @param outfilePhylo : Filename for phylogenetic outline image of splits network
#' @param outfileNexus : Filename for NEXUS output of splits network (SplitsTree4/5 compatible)
#' @param show : Boolean for showing outline on console
#' @param width : Width int
#' @param height : Height int
#' @param m_left : Restrict width on left by int
#' @param m_right : Restrict width on right by int
#' @param m_top : Restrict height on top by int
#' @param m_bot : Restrict height on bottom by int
#' @param font_size : Font size
#' @param scale_factor : Scaling outline for image
#' @examples
#' dists <- dist(cbind(c(0,1,1,1,1),c(0,0,0,1,1),c(0,1,1,1,1),c(0,1,0,1,1),c(0,0,0,0,0),c(0,1,1,0,0)), method = "manhattan",diag=TRUE,upper=TRUE)
#' labs <- c('Mouse','Fly','Rat','Zebrafish','Human')
#' out <- getSplits(labs, dists)
#' splits <- out[2][[1]]
#' cycle <- out[1][[1]]
#' getSplitVis(labs,cycle,splits,dists,'','')
#' @export
#' @importFrom reticulate import
#' @importFrom basilisk basiliskStart basiliskRun basiliskStop
getSplitVis <- function(labels,cycle,splits,matrix,outfilePhylo,outfileNexus,show=TRUE,width = 1000, height = 800,m_left = 100, m_right = 100, m_top = 100, m_bot = 100, font_size = 12, scale_factor =5) {

  cl <- basiliskStart(env4)
  cycSplit <- basiliskRun(cl, function() {
    path <- system.file("splitspy", package = 'SplitStats')
    X <- reticulate::import_from_path("splitspy", path = path)
    X$makeVis(labels,cycle,splits,matrix,outfilePhylo,outfileNexus,show,as.integer(width), as.integer(height),as.integer(m_left), as.integer(m_right), as.integer(m_top), as.integer(m_bot), as.integer(font_size), as.integer(scale_factor))
  })
  basiliskStop(cl)

}
